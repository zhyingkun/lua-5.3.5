# reload

1. 热更新模块实现思路和基础代码来自[云风的实现](https://blog.codingnow.com/2016/11/lua_update.html)
2. 整理并简化了云风版的逻辑

## 热更新的关键

1. 以模块为单位进行热更
2. 如何找到 更新的代码模块 和 内存中运行的对应模块 之间的差异？
3. 如何处理这些差异？

## 模块设计

1. 模块加载过程只执行 pairs 之类的无副作用的函数，最好是加载过程只存在变量定义和函数定义，保证加载过程没有模块逻辑（保留对外部功能的引用以便后续执行）
2. 提供初始化函数来执行模块初始化流程（热更过程不重复执行初始化，改动初始化函数则热更无法立即生效）
3. 配置数据的赋值在加载过程中完成，Runtime 数据的赋值在初始化流程中完成，用于 Runtime 的 Upvalue 一开始保持 nil 即可（热更会覆盖配置数据而不覆盖 Runtime 数据）
4. 规定模块中所有 Table 的 key 都是 string 或 number（降低 reload 过程的复杂度）

## 流程设计

1. 新模块的 require 在 sandbox 中进行
    1. 所有原本对外的引用都改成对 dummy 对象的引用，保证 require 之后得到模块没有对外引用（只允许有引用，不允许有执行）
    2. 对外的引用包括两种：对其他 module 的引用（包括数值或对象），对全局表字段或子字段的引用（包括数值或者对象）
    3. 模块更新成功之后再将所有 dummy 对象替换成真正的值
2. require 完沙盒中就会有一张由 function 和 table 构成的图（可能会有环或者循环引用的树）
3. require 所执行的 loader 也要记录下来，并第一时间将其 Upvalue 名为\_ENV 的变量设置为 nil
    1. 因为 loader 加载过程创建的新闭包可能也会使用跟 loader 同样的\_ENV，此时是引用同一个 Upvalue
    2. 加载过程该 Upvalue 是指向 sandbox 的，加载完需要立即设置为 nil 避免后续枚举的时候被扫描到
4. 沙盒中的每个 table、 function、dummy_object 都可以通过一个 path 来索引到（path 是由多层 key 构成的序列）
5. 根据新模块的 path 去找到对应的老版本，存在老版本则必须类型一致，否则拒绝更新（这一步只针对 table 和 function）
6. 此时得到了新旧模块之间的对象映射关系，执行合并策略
    1. 针对映射关系中的每一个 function
        1. Upvalue 本身要用老版的，Upvalue 的值非 Table 的话要用新版的，闭包要用新版的
        2. 扫描沙盒中所有 function 的 Upvalue，通过名称去对应旧版函数中找到对应的 Upvalue，使用 UpvalueID 来索引保证唯一性
        3. 老版本中两个 Upvalue 是分离的，新版本又共享起来了，这样导致不知道用哪个老版本的 Upvalue，此时直接抛异常拒绝热更
        4. 将所有新闭包的 Upvalue 去引用对应旧版的 Upvalue，并将非 Table 的 Upvalue 数值覆盖到旧版
    2. 针对映射关系中的每一个 table，遍历其字段（合并完留下旧 table 继续用，这里也包含模块自身这个 table）
        1. 只遍历新版 table 中的字段，旧版有新版无的字段不会被修改（可能是废弃字段，也可能是 Runtime 数据，不管它）
        2. dummy_object => 直接用新版覆盖旧版
        3. 旧版无新版有的字段 => 直接合并到老版本的 table 中（可能是新增值、新增函数、新增 table）
        4. 旧版有新版有的字段
            1. 该字段的值是 table 类型，则不用管（因为新旧版都有的 table 会在模块对象映射关系中，这里不需要重复处理）
            2. 其他类型的直接用新版的（包括值类型、闭包）
7. 将 loader 的\_ENV 设置成真正的\_ENV，这一步会将所有新创建的闭包所引用的\_ENV 的值都改成真正的\_ENV，因为是引用的同一个 Upvalue
8. 将所有 dummy 对象统一替换成真正的外部引用（包括 global 的和 module 的）
9. 最后，遍历整个 VM，将所有旧闭包用新闭包替换
