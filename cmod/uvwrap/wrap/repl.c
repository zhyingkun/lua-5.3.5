#define repl_c
#include <uvwrap.h>

#ifndef _WIN32 /* { */

#include <readline/readline.h>
#include <readline/history.h>

#define RL_INIT()
#define READLINE(p) readline(p)
#define SAVELINE(line) add_history(line)
#define FREELINE(b) free((void*)b)
#define RESTTERM() (void)rl_reset_terminal(NULL)

#else /* }{ */

#define LUA_MAXINPUT 512
#define RL_INIT() char buffer[LUA_MAXINPUT]

#define READLINE(p) \
  (fputs(p, stdout), \
   fflush(stdout), /* show prompt */ \
   fgets(buffer, LUA_MAXINPUT, stdin)) /* get line */
#define SAVELINE(line) \
  { \
    (void)line; \
  }
#define FREELINE(b) \
  { \
    (void)b; \
  }
#define RESTTERM()

#endif /* } */

#if !defined(lua_assert)
#define lua_assert(x) ((void)0)
#endif

/*
** {======================================================
** Functions from lua.c
** =======================================================
*/

#define LUA_PROGNAME "lua"
#define LUA_PROMPT "> "
#define LUA_PROMPT2 ">> "

static const char* progname = LUA_PROGNAME;

/*
** Prints an error message, adding the program name in front of it
** (if present)
*/
static void l_message(const char* pname, const char* msg) {
  if (pname)
    lua_printf("%s: ", pname);
  lua_printf("%s\n", msg);
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
// [-(0|1), +0, -], need 0 slot
static int report(lua_State* L, int status) {
  if (status != LUA_OK) {
    const char* msg = lua_tostring(L, -1);
    l_message(progname, msg);
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

/*
** Message handler used to run all chunks
*/
static int msghandler(lua_State* L) {
  const char* msg = lua_tostring(L, 1);
  if (msg == NULL) { /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") && /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING) /* that produces a string? */
      return 1; /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)", luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1); /* append a standard traceback */
  return 1; /* return the traceback */
}

/*
** Returns the string to be used as a prompt by the interpreter.
*/
// [-0, +1, -]
static const char* get_prompt(lua_State* L, int firstline) {
  const char* p;
  lua_getglobal(L, firstline ? "_PROMPT" : "_PROMPT2");
  p = lua_tostring(L, -1);
  if (p == NULL) {
    lua_pop(L, 1);
    p = (firstline ? LUA_PROMPT : LUA_PROMPT2);
    lua_pushstring(L, p);
  }
  return p;
}

/* mark in error messages for incomplete statements */
#define EOFMARK "<eof>"
#define marklen (sizeof(EOFMARK) / sizeof(char) - 1)

/*
** Check whether 'status' signals a syntax error and the error
** message at the top of the stack ends with the above mark for
** incomplete statements.
*/
// [-(0|1), +0, -], need 0 slot
static int incomplete(lua_State* L, int status) {
  if (status == LUA_ERRSYNTAX) {
    size_t lmsg;
    const char* msg = lua_tolstring(L, -1, &lmsg);
    if (lmsg >= marklen && strcmp(msg + lmsg - marklen, EOFMARK) == 0) {
      lua_pop(L, 1);
      return 1;
    }
  }
  return 0; /* else... */
}

/*
** Prints (calling the Lua 'print' function) any values on the stack
*/
// [-n, +0, -]
static void l_print(lua_State* L) {
  int n = lua_gettop(L);
  if (n > 0) { /* any result to be printed? */
    luaL_checkstack(L, LUA_MINSTACK, "too many results to print");
    lua_getglobal(L, "print");
    lua_insert(L, 1);
    if (lua_pcall(L, n, 0, 0) != LUA_OK) {
      l_message(progname, lua_pushfstring(L, "error calling 'print' (%s)", lua_tostring(L, -1)));
      lua_settop(L, 0);
    }
  }
}

// [-0, +0, -]
static void call_registry_funcs(lua_State* L, const char* name, const char* msg) {
  if (lua_getfield(L, LUA_REGISTRYINDEX, name) == LUA_TTABLE) {
    int idx = lua_gettop(L);
    lua_pushcfunction(L, msghandler);
    lua_pushnil(L);
    while (lua_next(L, idx)) {
      if (lua_pcall(L, 0, 0, idx + 1) != LUA_OK) {
        lua_printf(msg, lua_tostring(L, -1));
        lua_pop(L, 1);
      }
    }
    lua_pop(L, 1);
  }
  lua_pop(L, 1);
}

/* }====================================================== */

static int docall(lua_State* L, int narg, int nres) {
  int base = lua_gettop(L) - narg; /* function index */
  lua_pushcfunction(L, msghandler); /* push message handler */
  lua_insert(L, base); /* put it under function and args */
  int status = lua_pcall(L, narg, nres, base);
  lua_remove(L, base); /* remove message handler from the stack */
  return status;
}

#define REPL_PROMPT "_REPL_PROMPT_"
#define REPL_HISTORY "_REPL_HISTORY_"
#define REPL_ONEVAL "_REPL_ONEVAL_"

#define GET_REGISTRY_FIELD(field_) lua_getfield(L, LUA_REGISTRYINDEX, field_)
#define SET_REGISTRY_FIELD(field_) lua_setfield(L, LUA_REGISTRYINDEX, field_)
#define CLEAR_REGISTRY_FIELD(field_) \
  lua_pushnil(L); \
  lua_setfield(L, LUA_REGISTRYINDEX, field_)

// [-0, +0, -]
static const char* get_prompt_hold(lua_State* L, int firstline) {
  const char* prmt = get_prompt(L, firstline);
  SET_REGISTRY_FIELD(REPL_PROMPT);
  return prmt;
}

static void save_history(const char* line) {
  if (line != NULL && line[0] != '\0') { /* non empty? */
    SAVELINE(line); /* keep history */
  }
}

typedef struct {
  /* Context */
  uv_thread_t tid[1];
  /* Data Transmission */
  uv_async_t async[1];
  uv_sem_t sem[1];
  /* Read */
  const char* code;
  bool eof;
  /* Print */
  const char* prompt;
  const char* output;
  const char* history;
  bool running;
} lua_REPL;
static lua_REPL repl[1];

#define MSG_START "Multi thread REPL starting...\n"
#define MSG_STOP "Multi thread REPL end.\n"
static void read_line_thread(void* arg) {
  (void)arg;
  RL_INIT();
  lua_flushstring(MSG_START, sizeof(MSG_START));
  while (repl->running) { // for Ctrl-D in Unix or Ctrl-Z in Windows
    const char* buffer = READLINE(repl->prompt);

    // Read Send code and Wait
    repl->code = buffer;
    repl->eof = buffer == NULL;
    uv_async_send(repl->async);
    uv_sem_wait(repl->sem);

    FREELINE(buffer);
    save_history(repl->history);
  }
  lua_flushstring(MSG_STOP, sizeof(MSG_STOP));
  RESTTERM();
}

/*
** {======================================================
** REPL Default Deal
** =======================================================
*/

// [-(0|1), +0, -], need 0 slot
static int report_with_print(lua_State* L, int status) {
  if (status != LUA_OK) {
    lua_getglobal(L, "print");
    if (progname) {
      const char* msg = lua_tostring(L, -2);
      lua_pushfstring(L, "%s: %s", progname, msg);
    } else {
      // lua_pushfstring(L, "%s", msg);
      lua_pushvalue(L, -2);
    }
    if (lua_pcall(L, 1, 0, 0) != LUA_OK) {
      lua_pop(L, 1); // pop the error message
    }
    lua_pop(L, 1); /* remove message */
  }
  return status;
}

static bool firstline = true;
// [-0, +2, -]
int compile_source_code(lua_State* L, const char* code, const char** phistory) {
  char* b = (char*)code;
  size_t l = strlen(b);
  if (l > 0 && b[l - 1] == '\n') { /* line ends with newline? */
    b[--l] = '\0'; /* remove it */
  }
  bool hasClosure = false;
  if (firstline) {
    if (b[0] == '=') { /* for compatibility with 5.2, ... */
      lua_pushfstring(L, "return %s", b + 1); /* change '=' to 'return' */
    } else {
      lua_pushlstring(L, b, l);
      const char* retline = lua_pushfstring(L, "return %s;", b);
      if (luaL_loadbuffer(L, retline, strlen(retline), "=stdin") == LUA_OK) {
        lua_remove(L, -2); /* remove modified line */
        lua_insert(L, -2); // move the history string to top
        hasClosure = true;
      } else {
        lua_pop(L, 2); /* pop result from 'luaL_loadbuffer' and modified line */
      }
    }
  } else {
    GET_REGISTRY_FIELD(REPL_HISTORY);
    lua_pushliteral(L, "\n"); /* add newline... */
    lua_pushlstring(L, b, l);
    lua_concat(L, 3); /* join them */
  }
  size_t len = 0;
  const char* line = lua_tolstring(L, -1, &len);
  if (phistory) {
    *phistory = line;
  }
  SET_REGISTRY_FIELD(REPL_HISTORY);
  if (hasClosure) {
    return LUA_OK;
  }
  return luaL_loadbuffer(L, line, len, "=stdin"); /* try it */
}

static bool deal_repl_default(lua_State* L, const char* code, bool eof, const char** phistory, const char** pprompt) {
  bool running = true;
  *phistory = NULL;
  if (eof) { // Ctrl-D or Ctrl-Z+Enter
    if (firstline) {
      running = false;
      // lua_printf("\n"); // just for output newline, print direct
      lua_getglobal(L, "print");
      if (lua_pcall(L, 0, 0, 0) != LUA_OK) {
        lua_pop(L, 1); // pop the error message
      }
    } else {
      firstline = true; // end multi line
      GET_REGISTRY_FIELD(REPL_HISTORY);
      *phistory = lua_tostring(L, -1);
      lua_pop(L, 1);
      // lua_printf("%s\n", (char*)NULL); // just for output newline, print direct
      lua_getglobal(L, "print");
      lua_pushfstring(L, "%s", (char*)NULL);
      if (lua_pcall(L, 1, 0, 0) != LUA_OK) {
        lua_pop(L, 1); // pop the error message
      }
    }
  } else {
    const char* history;
    int status = compile_source_code(L, code, &history);
    if (incomplete(L, status)) {
      // incomplete will pop the error message if return true
      firstline = false;
    } else {
      firstline = true;
      *phistory = history;
      if (status == LUA_OK) {
        if (lua_gettop(L) != 1) {
          lua_replace(L, 1);
          lua_settop(L, 1); // Only left the closure
        }
        status = docall(L, 0, LUA_MULTRET);
        if (status == LUA_OK) {
          l_print(L); // print direct
        }
      }
      report_with_print(L, status); // will pop the error message
      call_registry_funcs(L, LUA_ATREPL, "Call atrepl failed: %s\n");
    }
  }
  *pprompt = get_prompt_hold(L, firstline);
  return running;
}

/* }====================================================== */

int uvwrap_repl_default(lua_State* L) {
  const char* code = luaL_optstring(L, 1, NULL);
  bool eof = luaL_checkboolean(L, 2);

  const char* history;
  const char* prompt;
  bool running = deal_repl_default(L, code, eof, &history, &prompt);

  lua_pushboolean(L, running);
  GET_REGISTRY_FIELD(REPL_PROMPT);
  if (history != NULL) { // for using REPL_HISTORY to cache multiline in default implementation
    GET_REGISTRY_FIELD(REPL_HISTORY);
  } else {
    lua_pushnil(L);
  }
  return 3;
}

static void exit_repl(lua_State* L) {
  uv_thread_join(repl->tid);
  uv_sem_destroy(repl->sem);
  uv_close((uv_handle_t*)repl->async, NULL);

  CLEAR_REGISTRY_FIELD(REPL_PROMPT);
  CLEAR_REGISTRY_FIELD(REPL_HISTORY);
  CLEAR_REGISTRY_FIELD(REPL_ONEVAL);
}

static int lua_doREPL(lua_State* L) {
  repl->output = NULL; // for multi thread, just print to stdout
  GET_REGISTRY_FIELD(REPL_ONEVAL);
  if (lua_isfunction(L, -1)) {
    lua_pushstring(L, repl->code);
    lua_pushboolean(L, repl->eof);
    int status = docall(L, 2, 3);
    if (status == LUA_OK) {
      repl->running = lua_toboolean(L, 1);
      repl->prompt = lua_tostring(L, 2);
      repl->history = lua_tostring(L, 3);
      if (repl->history != NULL) { // for using REPL_HISTORY to cache multiline in default implementationÃ
        SET_REGISTRY_FIELD(REPL_HISTORY);
      } else {
        lua_pop(L, 1);
      }
      SET_REGISTRY_FIELD(REPL_PROMPT);
      lua_pop(L, 1);
    } else {
      repl->running = false;
      repl->prompt = NULL;
      repl->history = NULL;
      report(L, status);
    }
  } else {
    lua_pop(L, 1);
    repl->running = deal_repl_default(L, repl->code, repl->eof, &repl->history, &repl->prompt);
  }

  /* Print Send result */
  uv_sem_post(repl->sem);

  if (!repl->running) {
    exit_repl(L);
  }
  lua_assert(0 == lua_gettop(L));
  return 0;
}

static void async_doREPL(uv_async_t* handle) {
  lua_State* L;
  GET_HANDLE_LUA_STATE(L, handle);
#ifndef NDEBUG
  int top = lua_gettop(L);
#endif
  lua_checkstack(L, 3);
  lua_pushcfunction(L, msghandler);
  int msgh = lua_gettop(L);
  lua_pushcfunction(L, lua_doREPL);
  report(L, lua_pcall(L, 0, 0, msgh));
  lua_pop(L, 1);
#ifndef NDEBUG
  lua_assert(top == lua_gettop(L));
#endif
}

int uvwrap_repl_start(lua_State* L) {
  if (repl->running) {
    return 0;
  }
  uv_loop_t* loop = luaL_checkuvloop(L, 1);
  lua_settop(L, 2);
  SET_REGISTRY_FIELD(REPL_ONEVAL);

  firstline = true; // for default c implementation

  /* Data Transmission */
  uv_async_init(loop, repl->async, async_doREPL);
  uv_sem_init(repl->sem, 0);
  /* Read */
  repl->code = NULL;
  repl->eof = false;
  /* Print */
  repl->prompt = get_prompt_hold(L, true);
  repl->output = NULL;
  repl->history = NULL;
  repl->running = 1;
  /* Context */
  signal(SIGINT, SIG_DFL); /* reset C-signal handler */
  uv_thread_create(repl->tid, read_line_thread, NULL);

  return 0;
}

int uvwrap_repl_read(lua_State* L) {
  const char* prompt = luaL_checkstring(L, 1);

  char* buffer = READLINE(prompt);
  lua_pushstring(L, buffer);
  FREELINE(buffer);
  return 1;
}

int uvwrap_repl_history(lua_State* L) {
  const char* history = lua_tostring(L, 1);
  save_history(history);
  return 0;
}
